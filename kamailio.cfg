#!KAMAILIO
debug=2
enable_tls=yes
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

listen=udp:0.0.0.0:5062 advertise 127.0.0.1:5062
listen=tcp:0.0.0.0:5062
listen=tls:0.0.0.0:8443

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "xlog.so"
loadmodule "tls.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "nathelper.so"
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
loadmodule "siputils.so"
loadmodule "sanity.so"
loadmodule "path.so"
loadmodule "usrloc.so"
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "nat_bflag", 6)
loadmodule "htable.so"
loadmodule "registrar.so"
modparam("registrar", "received_avp", "$avp(RECEIVED)")

modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "cors_mode", 2)
modparam("websocket", "sub_protocols", 1)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)

event_route[xhttp:request] {
    xlog("L_INFO", "HTTP Request: $rm $hu from $si:$sp\n");
    
    if ($Rp != 8443) {
        xhttp_reply("403", "Forbidden", "text/plain", "Wrong port");
        exit;
    }
    
    if ($hu =~ "^/ws") {
        xlog("L_INFO", "WebSocket handshake\n");
        
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake SUCCESS\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake FAILED\n");
            exit;
        }
    }
    
    xhttp_reply("200", "OK", "text/plain", "Kamailio");
    exit;
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket closed from $si:$sp\n");
}

request_route {
    xlog("L_INFO", "SIP Request: $rm $ru from $si:$sp proto=$proto\n");

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # Handle in-dialog requests (BYE, ACK, etc.) with Route headers
    if (has_totag()) {
        xlog("L_INFO", "In-dialog request detected: $rm\n");
        if (loose_route()) {
            xlog("L_INFO", "Following route for in-dialog $rm to: $ru\n");

            # Handle WebSocket routing
            handle_ruri_alias();

            # Check if destination is WebSocket and fix transport
            if ($ru =~ "transport=ws") {
                xlog("L_INFO", "WebSocket destination detected\n");
                set_contact_alias();

                # Fix destination URI to include transport=ws
                if ($du != $null && !($du =~ "transport=ws")) {
                    $du = $du + ";transport=ws";
                    xlog("L_INFO", "Fixed destination URI: $du\n");
                }

                # Force WSS send socket for WebSocket destinations
                force_send_socket(tls:0.0.0.0:8443);
            }

            t_on_reply("REPLY_TO_ASTERISK");
            if (!t_relay()) {
                sl_reply_error();
            }
            exit;
        } else {
            if (is_method("ACK")) {
                # ACK without matching transaction - absorb it
                if (t_check_trans()) {
                    t_relay();
                }
                exit;
            }
            sl_send_reply("404", "Not Found");
            exit;
        }
    }
    
    # Handle requests from Asterisk back to WebSocket clients
    if ($si == "127.0.0.1" && proto == UDP) {
        xlog("L_INFO", "Request from Asterisk to $ru\n");

        # Normalize domain for location lookup
        # Change sip:user@127.0.0.1:5062 to sip:user@sip.sumthing.space
        if ($rU) {
            $ru = "sip:" + $rU + "@sip.sumthing.space";
            xlog("L_INFO", "Normalized Request-URI to: $ru\n");
        }

        if (is_method("INVITE|BYE|CANCEL|ACK|UPDATE|NOTIFY|INFO")) {
            record_route();
        }
        
        t_on_reply("REPLY_TO_ASTERISK");
        # Lookup user location for routing to WebSocket
        xlog("L_INFO", "Looking up location for: $ru - from: $si
");
        if (!lookup("location")) {
            xlog("L_INFO", "Location NOT found for: $ru
");
            sl_send_reply("404", "Not Found");
            exit;
        }
        xlog("L_INFO", "Location found! Routing to: $du
");

        # Log Contact header before processing
        xlog("L_INFO", "Contact before alias: $ct\n");

        handle_ruri_alias();

        # Add alias to Contact for WebSocket response routing
        if ($du =~ "transport=ws") {
            set_contact_alias();
            xlog("L_INFO", "Added contact alias for WebSocket routing\n");
            xlog("L_INFO", "Contact after alias: $ct\n");
        }

        if (!t_relay()) {
            sl_reply_error();
        }
        exit;
    }
    
    # Handle WebSocket messages
    if (proto == WS || proto == WSS) {
        force_rport();

        # Check for peer-to-peer WebRTC calls (user-to-user)
        # Only for initial INVITE - in-dialog requests handled by loose_route above
        if (is_method("INVITE")) {
            # Save original request URI before lookup modifies it
            $var(original_ruri) = $ru;

            # Try to find destination user in location database
            if (lookup("location")) {
                # Found - this is a peer-to-peer call, route directly without Asterisk
                xlog("L_INFO", "WebRTC peer-to-peer INVITE: $fu -> $var(original_ruri) (routing to: $du)\n");

                record_route();
                handle_ruri_alias();

                # Add contact alias for response routing
                if ($du =~ "transport=ws") {
                    set_contact_alias();
                    xlog("L_INFO", "Added contact alias for peer-to-peer INVITE\n");
                }

                t_on_reply("REPLY_TO_ASTERISK");

                if (!t_relay()) {
                    xlog("L_ERR", "Failed to relay peer-to-peer INVITE\n");
                    sl_reply_error();
                }
                exit;
            } else {
                # Not found in location - restore URI and forward to Asterisk for services (IVR, etc.)
                $ru = $var(original_ruri);
                xlog("L_INFO", "Destination not registered locally, forwarding INVITE to Asterisk: $ru\n");
            }
        }

        # Forward to Asterisk for REGISTER, SUBSCRIBE, and service extensions
        xlog("L_INFO", "WebSocket SIP - forwarding to Asterisk UDP:5060\n");

        if (is_method("REGISTER")) {
            add_path_received();
            fix_nated_register();
            save("location", "0x04");
            # Location will be saved in reply route on 200 OK
            xlog("L_INFO", "REGISTER from: $fu to AOR: $tu
");
        }
        if (is_method("INVITE|SUBSCRIBE")) {
            record_route();
        }

        $du = "sip:127.0.0.1:5060;transport=udp";

        t_on_reply("REPLY_FROM_ASTERISK");
        if (!t_relay()) {
            sl_reply_error();
        }
        exit;
    }
    
    sl_send_reply("404", "Not Found");
    exit;
}

onreply_route[REPLY_FROM_ASTERISK] {
    xlog("L_INFO", "Reply from Asterisk: $rs $rr\n");
    
    # Save location when registration succeeds
    if (is_method("REGISTER") && status =~ "200") {
        xlog("L_INFO", "Registration successful - saving location for: $fu\n");
        save("location");
    }
}

onreply_route[REPLY_TO_ASTERISK] {
    xlog("L_INFO", "Reply to Asterisk: $rs $rr\n");

    # Handle Contact alias in replies from WebSocket clients
    if (nat_uac_test("64")) {
        # Client is behind NAT, fix contact
        fix_nated_contact();
        xlog("L_INFO", "Fixed NAT contact in reply\n");
    }
}
