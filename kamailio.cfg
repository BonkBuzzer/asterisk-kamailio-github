#!KAMAILIO
debug=2
enable_tls=yes
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

listen=udp:0.0.0.0:5062 advertise 127.0.0.1:5062
listen=tcp:0.0.0.0:5062
listen=tls:0.0.0.0:8443

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "xlog.so"
loadmodule "tls.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "nathelper.so"
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
loadmodule "siputils.so"
loadmodule "sanity.so"
loadmodule "path.so"
loadmodule "usrloc.so"
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "nat_bflag", 6)
loadmodule "htable.so"
loadmodule "registrar.so"
modparam("registrar", "received_avp", "$avp(RECEIVED)")

modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "cors_mode", 2)
modparam("websocket", "sub_protocols", 1)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)

event_route[xhttp:request] {
    xlog("L_INFO", "HTTP Request: $rm $hu from $si:$sp\n");
    
    if ($Rp != 8443) {
        xhttp_reply("403", "Forbidden", "text/plain", "Wrong port");
        exit;
    }
    
    if ($hu =~ "^/ws") {
        xlog("L_INFO", "WebSocket handshake\n");
        
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake SUCCESS\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake FAILED\n");
            exit;
        }
    }
    
    xhttp_reply("200", "OK", "text/plain", "Kamailio");
    exit;
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket closed from $si:$sp\n");
}

request_route {
    xlog("L_INFO", "SIP Request: $rm $ru from $si:$sp proto=$proto\n");
    
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }
    
    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }
    
    # Handle requests from Asterisk back to WebSocket clients
    if ($si == "127.0.0.1" && proto == UDP) {
        xlog("L_INFO", "Request from Asterisk to $ru\n");

        # Normalize domain for location lookup
        # Change sip:user@127.0.0.1:5062 to sip:user@sip.sumthing.space
        if ($rU) {
            $ru = "sip:" + $rU + "@sip.sumthing.space";
            xlog("L_INFO", "Normalized Request-URI to: $ru\n");
        }

        if (is_method("INVITE|BYE|CANCEL|ACK|UPDATE|NOTIFY|INFO")) {
            record_route();
        }
        
        t_on_reply("REPLY_TO_ASTERISK");
        # Lookup user location for routing to WebSocket
        xlog("L_INFO", "Looking up location for: $ru - from: $si
");
        if (!lookup("location")) {
            xlog("L_INFO", "Location NOT found for: $ru
");
            sl_send_reply("404", "Not Found");
            exit;
        }
        xlog("L_INFO", "Location found! Routing to: $du
");
        handle_ruri_alias();

        if (!t_relay()) {
            sl_reply_error();
        }
        exit;
    }
    
    # Handle WebSocket messages - forward to Asterisk UDP
    if (proto == WS || proto == WSS) {
        xlog("L_INFO", "WebSocket SIP - forwarding to Asterisk UDP:5060\n");
        
        force_rport();
                if (is_method("REGISTER")) {
            add_path_received();
            fix_nated_register();
            save("location", "0x04");
            # Location will be saved in reply route on 200 OK
            xlog("L_INFO", "REGISTER from: $fu to AOR: $tu
");
        }
        if (is_method("INVITE|SUBSCRIBE")) {
            record_route();
        }
        
        $du = "sip:127.0.0.1:5060;transport=udp";
        
        t_on_reply("REPLY_FROM_ASTERISK");
        if (!t_relay()) {
            sl_reply_error();
        }
        exit;
    }
    
    sl_send_reply("404", "Not Found");
    exit;
}

onreply_route[REPLY_FROM_ASTERISK] {
    xlog("L_INFO", "Reply from Asterisk: $rs $rr\n");
    
    # Save location when registration succeeds
    if (is_method("REGISTER") && status =~ "200") {
        xlog("L_INFO", "Registration successful - saving location for: $fu\n");
        save("location");
    }
}

onreply_route[REPLY_TO_ASTERISK] {
    xlog("L_INFO", "Reply to Asterisk: $rs $rr\n");
}
